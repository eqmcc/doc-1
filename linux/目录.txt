第一章 简介
1.01 UNIX特殊在什么地方？
1.02 谁接收用户的输入？
1.03 将程序设计成协同工作方式
1.04 用管道创建新工具
1.05 任何人都可以对shell编程
1.06 用于编辑的超级工具
1.07 让用户更加高效
1.08 shell的种类
1.09 正在运行哪个shell？
1.10 内部命令和外部命令
1.11 shell如何执行其他命令?
1.12 shell脚本的组成
1.13 为什么基本原理很重要？
1.14 内核和后台进程（daemon）
1.15 文件名
1.16 通配符
1.17 扩展文件名
1.18 谁处理通配符？
1.19 文件系统的树型结构
1.20 用户的主目录
1.21 创建路径
1.22 UNIX如何跟踪文件：索引节点
1.23 文件访问权限
1.24 超级用户（root）
1.25 访问目录
1.26 多用户系统可以做什么？
1.27 后台处理如何工作？
1.28 后台处理的一些注意事项
1.29 何时文件变成非文件？
1.30 重定向输入和输出
1.31 X Window系统
1.32 一个大的漏洞
1.33 UNIX联网和通信
1.34 UNIX有什么问题？

第一部分 请放轻松
第二章 登录
2.01 定制shell
2.02 shell设置文件――哪个. 何处和为什么
2.03 shell设置文件的内容
2.04 改变账户设置的提示：使shell随时可用
2.05 提高登录速度的技巧
2.06 在shell设置文件中使用绝对路径名
2.07 C shell设置文件没有被读入时该怎么办？
2.08 识别登录shell
2.09 用设置提示符测试加速C shell
2.10 设置提示符测试中的注意事项
2.11 使用$-测试的快速ksh和bash启动
2.12 不同终端的自动设置
2.13 设置每台主机所需的.cshrc.$HOST文件
2.14 motd.diff：在登录信息中显示新内容
2.15 整理登录：仅显示登录信息一次
2.16 已获得认可的shell：使用未获认可的登录shell
第三章 退出
3.01 退出时执行命令
3.02 在Bourne/Korn shell退出时执行命令
3.03 电子幸运饼
3.04 自动清除文件
3.05 阻止意外的C shell退出
3.06 阻止意外的Bourne shell退出
3.07 用screen分离会话
3.08 我使用的tty是什么？
第四章 组织主目录
4.01 什么？我们自己组织？
4.02 存放程序和脚本的bin目录
4.03 组织非执行脚本
4.04 Emacs小程序目录
4.05 私有（个人）目录
4.06 命名文件
4.07 生成更多的目录！
4.08 生成目录的方法
4.09 用.exrc文件建立vi
4.10 用whereiz找出所有的命令版本
第五章 设置用户终端类型
5.01 关于终端有许多内容需要了解
5.02 终端数据库的思想
5.03 登录时设置终端类型
5.04 用tset设置TERMCAP变量
5.05 查询用户终端类型：qterm
5.06 检查清单：登录时终端挂起
5.07 termcap和terminfo能完成什么和不能控制什么？
5.08 终端转义序列
5.09 设置擦除. 终止和中断字符
5.10 找出可以使用的终端名
5.11 用tset初始化终端
5.12 用tput初始化终端
第六章 shell及环境变量
6.01 环境变量有什么好处？
6.02 父－子关系
6.03 预定义的环境变量
6.04 PATH环境变量
6.05 PATH和path
6.06 TZ环境变量
6.07 日本现在是什么时间？
6.08 shell变量
6.09 特殊的C shell变量
6.10 用不同的临时环境执行命令
第七章 设置用户shell提示符
7.01 为什么要改变用户提示符？
7.02 设置提示符基础
7.03 C shell提示符在vi. rsh等中造成的麻烦
7.04 用内置命令进行快速提示符设置
7.05 多行shell提示符
7.06 用户终端状态行中的对话信息
7.07 初学者的“菜单提示符”
7.08 在shell提示符中突出显示
7.09 用$SHLVL显示subshell层
7.10 空白的shell提示符有什么好处？
7.11 用户提示符中的dirs：比$cwd好
7.12 通过外部命令发出信号来设置变量
7.13 bash中的预提示命令

第二部分 让计算机承担繁琐的工作
第八章 shell如何解释用户的输入
8.01 shell能做些什么？
8.02 bash简介
8.03 tcsh简介
8.04 命令评价和意外地覆盖文件
8.05 命令行的评价（evaluation）
8.06 输出命令行参数
8.07 设置用户搜索路径
8.08 用户不应该运行的命令目录
8.09 别名中的通配符
8.10 eval：当用户需要另外一个机会时
8.11 bash将用哪一个？
8.12 C shell将使用哪一个？
8.13 是“2>&1>file”还是“>file 2>&1”?
8.14 Bourne shell引用
8.15 Bourne shell引用和C shell引用之间的不同
8.16 引用处理文件名中的特殊字符
8.17 verbose和echo变量显示引用
8.18 here文档
8.19 “特殊”字符和操作符
8.20 有多少个反斜杠？
第九章 快捷地使用命令行
9.01 UNIX命令行的特殊之处
9.02 用行删除或字擦除快速修复一行
9.03 用CTRL-r重新显示命令行
9.04 能否使用通配符创建文件?
9.05 用{}建立串
9.06 串编辑（冒号）操作符
9.07 ksh和bash中的串编辑
9.08 文件名完成：加速文件名输入
9.09 在文件名完成中不要匹配无用文件
9.10 文件名完成并不总是万灵丹
9.11 用foreach循环重复一个命令
9.12 Bourne shell的for循环
9.13 多行命令,149次提示符
9.14 将here文档用于格式化信件等
9.15 针对复杂命令的一次性脚本
9.16 命令替换
9.17 用临时文件处理一系列文本
9.18 进程替换
9.19 超前输入
9.20 命令行中太多的文件
9.21 用xargs处理较长的命令行
9.22 xargs：空格和换行的问题
9.23 “参数太长”错误的解决方法
9.24 编辑ls－l. grep等的输出来获得文件列表
9.25 C shell重复命令
9.26 Expect
第十章 别名
10.01 创建自定义命令
10.02 常用命令的别名
10.03 带有命令行参数的C shell别名
10.04 ksh和bash中的别名
10.05 对脚本执行source命令
10.06 避免C shell的别名循环
10.07 如何在C shell别名中放入if-then-else
10.08 用makealias和quote在csh别名中修正引用
10.09 Shell函数
10.10 模拟的Bourne shell函数和别名
第十一章 历史机制
11.01 历史机制
11.02 历史简述
11.03 我喜爱!$
11.04 我喜爱!:n*
11.05 我喜爱^^
11.06 为安全起见,180对通配符使用!$
11.07 历史替换
11.08 重复命令循环
11.09 对一个文件执行一系列命令
11.10 首先用:p检查历史
11.11 退出时保存历史
11.12 将历史传给另外一个shell
11.13 shell命令行编辑
11.14 进行交互式历史编辑的其他方法
11.15 用histchars改变C shell的历史字符
11.16 不必改变历史字符
第十二章 作业控制
12.01 作业控制：快速运行作业,192停止失控作业
12.02 指向作业的其他方法
12.03 “当前作业”不总是用户所期望的
12.04 作业控制和自动写入：真正节省时间
12.05 系统超载？试着停止一些作业
12.06 作业改变状态时通知用户
12.07 用stty tostop停止后台输出
12.08 作业控制简述
12.09 用screen执行多个shell会话
第十三章 重定向输入和输出
13.01 使用标准输入和输出
13.02 cat只有一个参数并不够
13.03 （仅）将标准错误发给管道
13.04 用管道连接到分页程序时的问题
13.05 在C shell中重定向：是否也会捕获错误？
13.06 用noclobber确保I/O重定向的安全性
13.07 subshell操作符()
13.08 使用{列表}对Bourne shell命令进行分组
13.09 用tee将输出发送到更多的地方
13.10 如何将几个命令tee到一个文件？
13.11 tpipe――重定向stdout到多个地方
13.12 写到多个终端来示范
13.13 “文件名”－
13.14 空文件可以干什么？
13.15 满位存储桶能干什么:-)
13.16 用logerrs来存储和显示错误

第三部分 文件系统
第十四章 快速移动
14.01 熟悉文件系统
14.02 使用相对路径和绝对路径名
14.03 当前目录的好处是什么？
14.04 UNIX如何寻找用户的当前目录？
14.05 cdpath：当用户改变目录时可以节省时间
14.06 shell的pushd和popd命令
14.07 pushd的很好的别名
14.08 用别名快速cd
14.09 通过目录的首部执行cd命令
14.10 变量帮助用户寻找目录和文件
14.11 快速查找（任何用户的）主目录
14.12 用shell变量找到用户的位置
14.13 用户究竟位于哪个目录？
14.14 用户进入/退出一个目录时自动设置
第十五章 通配符
15.01 文件命名通配符
15.02 文件名通配符简述
15.03 在Korn（和Bourne）shell中增加{}操作符
15.04 如果通配符不匹配怎么办？
15.05 用通配符匹配所有“圆点文件”
15.06 在路径名中不应该使用通配符的情形
15.07 用grep－l获取匹配文件列表
15.08 用grep－c获取非匹配文件列表
15.09 nom：列出不匹配通配符的文件
15.10 仅匹配目录的通配符
第十六章 寻找指定文件
16.01 除了find命令以外的方法
16.02 用ls－t和ls－u寻找最老的和最新的文件
16.03 重排ls列表
16.04 用ls－R列出所有子目录
16.05 三个UNIX文件时间
16.06 clf,ccls:c“被压缩的”ls列表
16.07 ls的快捷方式：ll, lf, lg等
16.08 ls－d选项
16.09 列出最近改变的文件的别名
16.10 findcmd：在搜索路径中寻找命令
16.11 用ls－A和－a显示隐藏文件
16.12 有用的ls别名
16.13 不能访问一个文件吗？寻找文件名中的空格
16.14 显示文件名中的非打印字符
16.15 用于UNIX转换的有趣脚本：dir, ..., ...
16.16 自动选择一个惟一的文件名
16.17 从文件的路径名获取目录名称
16.18 列出刚刚创建/编辑的文件
16.19 stree：简单目录树
16.20 可视目录树程序vtree
16.21 找出具有相同名称的所有目录
16.22 用dircmp比较两个目录树
16.23 比较两个目录树中的文件名
16.24 根据类型计数文件
16.25 由时间和大小列出文件
16.26 用findtext寻找文本文件
16.27 newer：打印最新文件的名称
16.28 oldlinks：寻找未连接的符号链接
16.29 sls：带有可选格式的超级ls
第十七章 用find寻找文件
17.01 find命令很好, 问题是如何使用它
17.02 深入目录树
17.03 不要忘记－print
17.04 寻找有特殊名称的文件
17.05 寻找旧文件
17.06 成为find搜索操作符的专家
17.07 寻找待找文件的时间
17.08 确切的文件时间比较
17.09 －newer的问题
17.10 对用户所找到的文件执行命令
17.11 使用－exec创建自定义的测试
17.12 用一个命令寻找多个内容
17.13 根据类型搜索文件
17.14 根据大小搜索文件
17.15 根据权限搜索文件
17.16 根据所有者和组搜索
17.17 复制一个目录树（不包含带有find {}操作符的路径名）
17.18 使用“快速find”
17.19 用find数据库更快速地寻找文件
17.20 grep目录树
17.21 lookfor：哪个文件含有那个词?
17.22 寻找到文件的链接
17.23 用－prune寻找文件
17.24 在find中略过目录树的一些部分（更具选择性的－prune）
17.25 阻止find搜索联网的文件系统
第十八章 链接. 重命名和拷贝文件
18.01 拷贝文件的复杂之处
18.02 目录中真正有什么？
18.03 有两个或更多名称的文件
18.04 关于链接的更多内容
18.05 创建和删除链接
18.06 陈旧的符号链接
18.07 链接目录
18.08 为符号链接显示实际的文件名
18.09 重命名. 拷贝或者比较一组文件
18.10 完成任务的方法不止一种
18.11 用ren重命名文件
18.12 交互式地重命名一列文件
18.13 另一种方法
18.14 重链接多个符号链接
18.15 用cp－r拷贝目录树
18.16 用（tar | tar）拷贝目录树
第十九章 创建和读取档案
19.01 打包和移动
19.02 shell档案简介
19.03 unshar：拆除shell档案
19.04 unshar的一个简单版本
19.05 使用tar创建和打开档案
19.06 GNU tar范例
19.07 从压缩档案中解压文件
19.08 冗长tar的问题
19.09 一个系统V的磁带存档程序：cpio
第二十章 备份文件
20.01 tar简述
20.02 生成用户自己的备份
20.03 如何用本地磁带驱动器生成备份
20.04 使用tar恢复磁带上的文件
20.05 在远程磁带驱动器上使用tar
20.06 在远程机器上写磁带驱动器
20.07 为选择的备份创建时间标记文件
20.08 通知tar排除或者包含指定文件
20.09 程序不能识别通配符时的情况
20.10 避免对tar使用绝对路径
20.11 按正确的顺序获得tar的参数
20.12 用SCCS或者RCS保护文件
20.13 SCCS基础
20.14 RCS基础
20.15 用rcsrevs列出RCS修正号
第二十一章 关于管理文件的更多内容
21.01 混杂的内容
21.02 存放临时文件的更好的地方：/tmp
21.03 命名临时文件
21.04 为什么/tmp和/usr/tmp都要使用?
21.05 文件最后访问时间的好处
21.06 文件的索引节点改变（不是“创建”!）时间
21.07 用touch设置文件的修改时间
21.08 MAILCHECK和mail变量的使用不局限于对邮件的检查
21.09 用make自动更新文件的打印输出
21.10 在屏幕顶部保留一个目录列表：dirtop
21.11 比较安全的删除.c移动和拷贝
21.12 将文件复制到目录
21.13 用stat读取索引节点
21.14 自动将日期附加给文件名
第二十二章 文件的安全性.c所有权及共享
22.01 文件所有权和安全性的介绍
22.02 文件和目录权限介绍
22.03 谁将拥有新文件？
22.04 设置确切的umask
22.05 在一个目录中带有setgid位的组权限
22.06 用sticky位保护文件
22.07 使用chmod来改变文件的权限
22.08 方便的chmod＝操作符
22.09 保护重要文件：让这些文件不可写
22.10 cx, cw, c-w：快速改变文件权限
22.11 漏洞：不使用写权限来修改文件
22.12 用户可以访问但不能列出的目录
22.13 组和组所有权
22.14 将用户加入到一个组来拒绝权限
22.15 改变权限
22.16 用cpmod复制权限
22.17 提高crypt安全性的方法
22.18 为了安全起见清除终端来阻止老化
22.19 shell脚本必须为可读和（通常）可执行
22.20 为什么不能在BSD UNIX下改变文件的所有权？
22.21 没有chown如何改变文件的所有权呢?
22.22 su命令并不仅仅对于超级用户可用
第二十三章 删除文件
23.01 创建和删除文件的循环
23.02 rm命令和它的危险
23.03 使rm更安全的技巧
23.04 用yes总是回答“Yes”或者“No”
23.05 删除一些, 留下一些
23.06 交互式地删除文件时比较快的方法
23.07 在目录中进行比较安全的文件删除
23.08 安全删除：正面的和反面的
23.09 delete：避免意外地删除文件
23.10 无所顾忌地删除：rm -f
23.11 删除名字特殊的文件
23.12 使用通配符删除名字特殊的文件
23.13 删除空名文件
23.14 处理以短划线（-）开始的文件名
23.15 用unlink删除名字特殊的文件
23.16 由索引号删除一个名字特殊的文件
23.17 关于删除目录的问题
23.18 如何创建和删除目录
23.19 删除（BSD）不需要阅读的手册页
23.20 删除旧文件
23.21 删除除了某个文件以外的所有文件
23.22 使用find命令清除不需要的文件
第二十四章 获取磁盘空间的其他方法
24.01 清空而不是删除一个文件
24.02 用“位存储桶”日志文件和邮箱节省空间
24.03 删除打开的文件并不是一个好想法
24.04 使用链接节省空间
24.05 限制文件大小
24.06 使用制表符节省空间
24.07 压缩文件以节省空间
24.08 节省空间：tar和压缩目录树
24.09 磁盘空间的大小
24.10 zloop：在压缩文件上执行一个命令
24.11 用zvi. zex和zed来编辑压缩文件
24.12 压缩目录树：良好的调整
24.13 用strip在可执行文件中节省空间
24.14 小心使用strip
24.15 整理目录
24.16 整理大型目录
24.17 磁盘限额
24.18 大型文件不一定占用许多磁盘空间

第四部分 深入文件
第二十五章 显示文件内容
25.01 破解难题
25.02 运用cat的四种方法
25.03 使用more对文件分页
25.04 “less”分页程序：功能比“more”更强大
25.05 对压缩文件. RCS文件和不可打印文件分页
25.06 空白处究竟是什么？
25.07 用cat－v或者od－c显示非打印字符
25.08 寻找文件类型
25.09 增加和删除空白
25.10 压缩额外的空白行
25.11 crush：一个略过所有空白行的cat
25.12 两倍行距, 三倍行距……
25.13 pushin：删除额外的空白
25.14 如何查看一个文件的末尾：tail
25.15 较好地控制tail
25.16 在文件增长时如何查看它？
25.17 没有tail时的别名
25.18 观察几个文件的增长
25.19 使用flip来反转长文件中的行
25.20 打印文件头的内容
25.21 加行号
第二十六章 正则表达式（模式匹配）
26.01 这是一个表达式
26.02 不要把正则表达式与通配符混淆
26.03 理解表达式
26.04 在正则表达式中使用元字符
26.05 使正则表达式准确无误
26.06 正则表达式到底匹配什么？
26.07 限制匹配范围
26.08 不匹配不喜欢的字符
26.09 不同UNIX程序的有效元字符
26.10 带实例的模式匹配快速参考
第二十七章 在文件中查找
27.01 grep的不同版本
27.02 用grep搜索文本
27.03 找出不匹配的文本
27.04 仅为单词时才匹配的模式
27.05 用egrep对文本扩展查找
27.06 快速grep不快
27.07 用grep查找一个模式列表
27.08 glimpse和agrep
27.09 新的grep更快
27.10 用rcsgrep搜索RCS文件
27.11 使用sed进行多行上下文的grep搜索
27.12 用perl生成自定义的grep命令（等等）
27.13 用Perl编写的更多类似于grep的程序
27.14 复合搜索
27.15 快速的限制性搜索
27.16 不区分大小写的搜索
27.17 在列中搜索字符
27.18 用“look”进行快速搜索和拼写检查
27.19 寻找二进制文件内部的单词
27.20 高亮度的grep
第二十八章 文件比较
28.01 用diff检查差别
28.02 用diff3比较三个不同的版本
28.03 上下文diff
28.04 并排diff：sdiff
28.05 并排比较文件
28.06 用sdiff选择
28.07 用于非常长文件的diff：bdiff
28.08 更友好的diff输出
28.09 由diff建立的exc脚本
28.10 diff和制表位的问题
28.11 cmp和diff
28.12 用comm比较两个文件
28.13 make不仅仅对程序员有用！
28.14 make的更多用途
28.15 用diffmk显示troff文件中的变化
第二十九章 拼写检查. 词计数和文本分析
29.01 UNIX的spell命令
29.02 用ispell对拼写进行交互式的检查
29.03 如何拼写某个单词？
29.04 深入spell
29.05 向ispell的字典添加单词
29.06 计算行. 单词和字符：wc
29.07 计算每个单词使用的次数
29.08 查找a a这样的双字
29.09 寻找闭合形式
29.10 只对单词操作c

第五部分 文本编辑
第三十章 vi使用提示及技巧
30.01 详细讲述vi和ex编辑器的理由
30.02 内容概要
30.03 Mice与vi的对比
30.04 运用vi进行多文件编辑
30.05 文件之间的编辑
30.06 vi与ex的局部设置
30.07 利用缓冲区移动或复制文本
30.08 利用编号的缓冲区恢复更多的删除内容
30.09 使用搜索模式和全局命令
30.10 在vi和ex中确认替换
30.11 保存原始文件,521写入新文件
30.12 部分文件的保存
30.13 添加到一个现有文件
30.14 利用模式移动文本块
30.15 实用的全局命令（模式匹配）
30.16 计算出现的次数, 取消搜索限制
30.17 将一行内所有的单词大写
30.18 为个别文件自动设置vi选项
30.19 modelines：缺点还是优点？
30.20 适合多种编辑器的设置文件, 以搜索启动
30.21 单独设置文件
30.22 用UNIX命令过滤文本
30.23 vi更安全的全文过滤
30.24 vi/ex文件恢复与联网文件系统
30.25 退出时, vi－r可能不能写入恢复的缓冲区内容
30.26 shell转义：使用一个UNIX命令时运行另一个命令
30.27 vi复合搜索
30.28 用ctags和tags来跟踪函数和包含文件
30.29 设置多个tags文件
30.30 vi比双重功能的函数键更智能化
30.31 vi缩写词
30.32 作为命令使用vi缩写词（在vi间剪切和粘贴）
30.33 用vi缩写词修改排版
30.34 vi行命令与字符命令
30.35 临时空间溢出？使用另一个目录
30.36 ex的打开模式可以很方便
30.37 整理文本行
30.38 使用撤消命令来寻找位置
第三十一章 在vi中创建自定义命令
31.01 为什么敲键的次数比需要的更多？
31.02 用vi映射命令来节省时间和输入量
31.03 使用map!的缺点
31.04 vi 的@函数
31.05 运行vi时在窗口里进行粘贴的键映射
31.06 保护键不被ex解释
31.07 用于重复编辑的映射
31.08 vi中键映射的更多例子
31.09 .exrc文件范例
31.10 重复vi键映射
31.11 不使用CAPS LOCK输入大写字母
31.12 文本输入模式中不使用光标移动键的光标移动
31.13 让光标键在vi文本输入模式下工作
31.14 vi映射的重要功能：使用noremap
31.15 避免vi执行复杂的宏
31.16 用于截断长文本行的vi宏命令
第三十二章 GNU Emacs
32.01 Emacs：另一种编辑器
32.02 Emacs的特点：一本流水账
32.03 用户化及如何取消该功能
32.04 备份和自动保存文件
32.05 将Emacs设置为覆盖模式
32.06 命令完成
32.07 Mike最喜欢的时间节省器
32.08 合理高效地搜索
32.09 在使用Emacs之前不设置PWD
32.10 在文件中插入二进制字符
32.11 使用缩写词模式
32.12 解决Emacs的流控制问题
32.13 不合理的消遣
第三十三章 批量编辑
33.01 为什么行编辑器不是很难上手？
33.02 编写编辑脚本
33.03 行定位
33.04 有用的ex命令
33.05 在vi中运行编辑脚本
33.06 通过只编辑一个文件来改变多个文件
33.07 ed/ex批量编辑：避免在无匹配时出错
33.08 批量编辑注意事项：大型文件--编辑器的炸弹
33.09 patch：不同文件的通用升级程序
33.10 用qsubst命令从命令行进行快速全程搜索
33.11 快速参考：awk
33.12 awk版本
第三十四章 sed流编辑器
34.01 关于sed必须了解的两点
34.02 调用sed
34.03 测试和使用sed脚本：checksed,
34.04 sed寻址基础
34.05 脚本中命令的顺序
34.06 每次只做一件事
34.07 定界正则表达式
34.08 sed替换式中的换行符
34.09 引用替换式中的搜索字符串
34.10 引用搜索字符串的一部分
34.11 搜索和替换：多个匹配中的某一个
34.12 文本变换
34.13 保留空间：保留缓冲区
34.14 转换一行中的部分文本
34.15 跨行编辑
34.16 谨慎的代笔人
34.17 搜索跨行模式
34.18 删除多行文本
34.19 在哪里都能进行编辑, 除了……
34.20 sed的测试命令
34.21 sed退出命令的几个用途
34.22 sed退出命令中隐藏的危险
34.23 shell脚本中的sed换行符. 引用和反斜杠
34.24 快速参考：sed
第三十五章 超越文本编辑
35.01 为什么不是？
35.02 用fmt整理文本
35.03 fmt的可选项
35.04 recomment：整理程序注释块
35.05 用behead删除邮件/新闻的标题
35.06 用dd实现低级的文件清除
35.07 offset：缩进文本
35.08 使文件中的行居中
35.09 在固定点分割文件：split
35.10 根据上下文分割文件：csplit
35.11 用tr过滤字符
35.12 在ASCII码与EBCDIC码之间进行转换
35.13 用dd进行其他转换
35.14 用cut剪切列或者字段
35.15 用colrm剪切列
35.16 用cols自动创建文本列
35.17 用pr使文本成列排列
35.18 按列粘贴文本
35.19 用join连接文本行
35.20 快速参考：uniq
35.21 用IFS分割字符串
35.22 对齐参差不齐的列
35.23 旋转文本
第三十六章 排序
36.01 排序
36.02 排序字段：sort是如何排序的？
36.03 更改字段定界符
36.04 空白字段定界符造成的混淆
36.05 按字母和数字排序
36.06 各种各样的排序提示
36.07 对多行记录项进行排序
36.08 lensort：根据长度对行进行排序
36.09 根据姓氏对名单排序
第三十七章 Perl--反常. 折衷的垃圾陈列器
37.01 关于Perl打算和不打算介绍的内容
37.02 为什么要学习Perl语言之一
37.03 程序员的三种美德
37.04 为什么要学习Perl语言之二
37.05 Perl 5
第六部分 进程管理
第三十八章 开始. 停止和杀死进程
38.01 本章内容
38.02 fork和exec
38.03 管理进程：全部的概念
38.04 subshell
38.05 命令ps
38.06 控制终端
38.07 为什么ps把一些命令显示在小括号内？
38.08 什么是信号？
38.09 杀死前台作业
38.10 用kill命令销毁进程
38.11 打印机队列监视器：一个可重新启动的daemon shell脚本
38.12 杀死所有的进程
38.13 交互地杀死匹配某个模式的进程
38.14 进程失去了控制怎么办?--停止它们
38.15 清除一个不能杀死的进程
38.16 为什么用户不能杀死僵死进程？
38.17 在csh中退出时自动杀死后台进程
38.18 nohup
第三十九章 时间和性能
39.01 时间是什么？
39.02 定时程序
39.03 csh时间变量
39.04 用runtime计算平均命令运行时间
39.05 为什么系统会那么慢？
39.06 lastcomm：正在运行什么命令以及需要用多长时间？
39.07 检查系统的负载：uptime
39.08 大环境会让系统速度变慢
39.09 明白什么时候对其他用户友好以及什么时候不友好
39.10 nice的一个注意事项
39.11 在BSD UNIX系统下改变作业的优先权
39.12 什么使得计算机变慢以及怎样改变它？
第四十章 延迟执行
40.01 非高峰时期的作业提交
40.02 等待一会儿：sleep
40.03 at命令
40.04 选择at（所希望）运行的shell
40.05 避开其他at和cron作业
40.06 系统V.4的分批队列
40.07 使at作业隐藏
40.08 自动重新启动at作业
40.09 察看和删除作业
40.10 nextday,701nextweekday：明天或者下一个工作日
40.11 发送给自己的提醒邮件c
40.12 定期执行程序：工具cron
40.13 添加crontab项
40.14 在一个cron项中包含标准输入
40.15 crontab脚本使得crontab编辑更容易/更安全

第七部分 终端设备和打印机
第四十一章 终端与串行线设置
41.01 更深入的研究
41.02 stty及其所有内容
41.03 用stty找出终端设置
41.04 UNIX系统怎样处理制表符？
41.05 为什么有的系统在提示符处退格？
41.06 使用sleep程序来保留端口设置
41.07 从终端读取长文本行
41.08 pty和窗口系统
41.09 用来调整终端的命令
41.10 在shell程序中使用terminfo的性能
41.11 termcap和terminfo是如何描述终端的？
41.12 找出终端特殊键发送的字符
第四十二章 终端设备可能出现的问题
42.01 搞清终端的含义
42.02 修改中止的终端或作业
42.03 为什么有时候改变TERM却不起作用？
42.04 用于重置终端的核对清单
42.05 核对清单：屏幕尺寸是否合适？
42.06 屏幕尺寸测试文件
42.07 termtest：发送重复的字符到终端
42.08 擦除错误信息太快怎么办？试试这些办法
第四十三章 打印
43.01 打印介绍
43.02 针对UNIX系统的打印介绍
43.03 用命令lpc实现打印机控制
43.04 使用不同的打印机
43.05 使用符号链接用于假脱机
43.06 打印到一个终端打印机
43.07 打印前的快速简单的格式化
43.08 用pr和fold修改页边空白
43.09 缩进文本用于打印
43.10 不用pr在文件上添加文件名页眉
43.11 很大的字母：banner
43.12 排版概述
43.13 文本格式化程序nroff,744troff,744ditroff……
43.14 nroff/troff和宏命令包
43.15 从源文件到打印机
43.16 groff
43.17 没有nroff吗？试试gnroff或awf
43.18 nroff怎样生成粗体字和下划线？怎样撤消它？
43.19 撤消引导制表符以及其他一些琐事
43.20 显示troff宏定义
43.21 用sed预处理troff输入
43.22 把文本文件转换成PostScript
43.23 psselect：从某PostScript文件中打印某些页
43.24 其他PostScript实用程序
43.25 可移植的位图软件包

第八部分 shell编程
第四十四章 针对有经验用户的shell编程指南
44.01 每个人都必须学习一些shell编程的内容
44.02 编写一个简单的shell程序
44.03 shell究竟是什么？
44.04 测试系统是如何执行文件的
44.05 用Bourne shell的case测试字符串的值
44.06 case语句中的模式匹配
44.07 UNIX进程的退出状态
44.08 用if语句测试退出状态
44.09 测试成功
44.10 测试退出状态的循环
44.11 设置shell（脚本）的退出状态
44.12 捕获由中断引起的退出
44.13 read：从键盘读取输入
44.14 把awk. sed等插入shell脚本中
44.15 处理shell脚本中的命令行参数
44.16 用一个for循环处理命令行参数
44.17 用while和shift处理参数
44.18 标准命令行解析
44.19 Bourne shell的set命令
44.20 test：测试文件和字符串
44.21 为一个新命令挑选名称
44.22 查找一个或者多个程序名
44.23 使用.和source命令阅读文件
第四十五章 针对新手的shell编程指南
45.01 基础以外的东西
45.02 关于#和#!的故事
45.03 可以不需要shell来运行你的脚本吗？那么就不要使用它
45.04 试一试#!
45.05 一个自显示的文件以及#!所做的事
45.06 确保用户的脚本能够被Bourne shell运行
45.07 exec命令
45.08 向子进程传递信号
45.09 不被赏识的Bourne shell“：”操作符
45.10 为了安全性和易于清除,793只要文件一打开就删除它
45.11 多用途的jot命令
45.12 参数替换
45.13 节省磁盘空间与编程：一个程序的多个名称
45.14 找出最后的命令行参数
45.15 如何清除所有的命令行参数？
45.16 for循环的标准输入
45.17 编写使用多个变量的for循环
45.18 使用basename和dirname
45.19 使用了一些循环控制命令的while循环
45.20 概述：打开文件和文件描述符
45.21 n>&m：交换标准输出和标准错误
45.22 逐行处理文件
45.23 重定向I/O循环的输入输出
45.24 shell可以从它的标准输入读入脚本,807但是……
45.25 来自标准输入的shell脚本
45.26 引用hereis文档结束符：sh 和csh
45.27 为保护“秘密”回答而关闭回显
45.28 快速参考：expr
45.29 使用expr测试字符串中的字符
45.30 获取字符串的一部分
45.31 嵌套的命令替换
45.32 一个更好的读取命令：grabchars
45.33 用一个case语句测试两个字符串
45.34 Bourne shell中的数组
45.35 在脚本中使用控制字符
45.36 shell锁文件
第四十六章 shell脚本调试和一些注意事项
46.01 调试shell脚本的一些提示
46.02 引用很麻烦吗？想一想,822然后使用命令echo
46.03 用Bournecshell调试程序显示一个shell变量
46.04 终止数字测试中的语法错误
46.05 终止字符串测试中的语法错误
46.06 注意Bourne shell的－e程序错误
46.07 引用和命令行参数
46.08 检测失败的内置命令
46.09 如果命令没有返回状态,829则测试错误消息
46.10 一个可移植的echo命令
第四十七章 避免使用C shell编程
47.01 为什么？
47.02 C shell编程被认为是有害的
47.03 用if编写条件语句
47.04 C shell变量操作符和表达式
47.05 使用C shell数组
47.06 快速参考：C shell的switch语句

第九部分 其他内容
第四十八章 办公自动化
48.01 内容概要
48.02 在线电话和地址列表
48.03 屏幕上的便签簿
48.04 自动备忘录和更多功能：日历
48.05 leave：按时退出的神奇助手
48.06 为任意月份或年份获得日历：cal
48.07 标识今天日期的cal
48.08 132列终端或打印机使用的日历程序
48.09 使用pcal程序获得PostScript日历
48.10 使用名字和地址
48.11 索引（index）数据库程序
48.12 使用带有过滤器的index
第四十九章 数字操作
49.01 bc：shell提示符下的简单数学运算
49.02 bc:c十六进制或二进制换算
49.03 基本换算中的注意事项
49.04 bc的正弦和余弦函数是以弧度为单位的
49.05 使用cvtbase进行基本换算
49.06 使用expr进行快速运算
49.07 使用addup对一列进行统计
49.08 拥有一个电子表格软件是一件非常美妙的事
49.09 使用ipl处理商用图形
第五十章 帮助--在线文档等
50.01 UNIX在线文档
50.02 apropos命令
50.03 在没有apropos的系统中实现apropos的功能
50.04 whatis：单行命令的摘要
50.05 whereis: 找出命令的位置
50.06 搜索在线手册页
50.07 UNIX系统如何记住它们的名字？
50.08 使用的是哪个版本？
50.09 阅读排列索引
50.10 不用学习troff就可建立用户自己的手册页
50.11 使用－man宏编写一个简单的手册页
50.12 常见的UNIX错误信息
第五十一章 各种各样有用的程序和珍品
51.01 最后的宝藏
51.02 UNIX怎样保存时间？
51.03 ASCII符：列表和获得值
51.04 系统里有谁？
51.05 用script拷贝用户所做的事情
51.06 清除脚本文件
51.07 当用户失去耐心时
51.08 用行话输入
51.09 制作“登录”shell
51.10 date命令
51.11 制作测试用的任意大小的文件
51.12 你没有足够的笑脸吗？
第五十二章 光盘中的内容
52.01 介绍
52.02 免费软件和UNIX标准程序
52.03 用于UNIX的压缩软件包
52.04 光盘内容的简要描述
52.05 使用超级工具光盘
52.06 没有光驱怎么办？
52.07 获得软件的其他途径
52.08 从源代码构造程序
52.09 来自RTR的软件支持
第五十三章 术语表

